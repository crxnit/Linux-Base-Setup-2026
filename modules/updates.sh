#!/bin/bash
# ============================================================================
# System Updates and Time Synchronization Module
# ============================================================================
# Functions for system updates, unattended upgrades, and NTP configuration
# ============================================================================

perform_system_updates() {
    log_section "System Updates"
    
    if [[ "$PERFORM_UPDATES" != "true" ]]; then
        log_info "System updates disabled"
        return 0
    fi
    
    log_info "Updating package lists"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would update and upgrade system"
        return 0
    fi
    
    # Update package lists
    if apt-get update >> "$LOG_FILE" 2>&1; then
        log_success "Package lists updated"
    else
        log_error "Failed to update package lists"
        return 1
    fi
    
    # Upgrade packages
    log_info "Upgrading installed packages (this may take a while)"
    if DEBIAN_FRONTEND=noninteractive apt-get upgrade -y >> "$LOG_FILE" 2>&1; then
        log_success "System packages upgraded"
    else
        log_error "Failed to upgrade packages"
        return 1
    fi
    
    # Full upgrade (dist-upgrade)
    if prompt_yes_no "Perform full system upgrade (dist-upgrade)?" "y"; then
        log_info "Performing full system upgrade"
        if DEBIAN_FRONTEND=noninteractive apt-get dist-upgrade -y >> "$LOG_FILE" 2>&1; then
            log_success "Full system upgrade complete"
        else
            log_warning "Full system upgrade encountered issues"
        fi
    fi
    
    # Clean up
    log_info "Cleaning up package cache"
    apt-get autoremove -y >> "$LOG_FILE" 2>&1
    apt-get autoclean -y >> "$LOG_FILE" 2>&1
    
    log_success "System update complete"
    
    return 0
}

configure_unattended_upgrades() {
    log_section "Unattended Upgrades Configuration"
    
    if [[ "$ENABLE_UNATTENDED_UPGRADES" != "true" ]]; then
        log_info "Unattended upgrades disabled"
        return 0
    fi
    
    log_info "Configuring automatic security updates"
    
    # Install unattended-upgrades
    install_package "unattended-upgrades"
    install_package "apt-listchanges"
    
    local ua_conf="/etc/apt/apt.conf.d/50unattended-upgrades"
    local auto_conf="/etc/apt/apt.conf.d/20auto-upgrades"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would configure unattended upgrades"
        return 0
    fi
    
    backup_file "$ua_conf"
    
    # Distribution-specific origins
    local distro
    distro=$(get_distribution)
    
    if is_ubuntu; then
        # Ubuntu-specific configuration
        cat > "$ua_conf" <<EOF
// Unattended-Upgrade configuration for Ubuntu
// Generated by linux-base-setup on $(date)

Unattended-Upgrade::Allowed-Origins {
    "\${distro_id}:\${distro_codename}";
    "\${distro_id}:\${distro_codename}-security";
    "\${distro_id}:\${distro_codename}-updates";
    "\${distro_id}ESMApps:\${distro_codename}-apps-security";
    "\${distro_id}ESM:\${distro_codename}-infra-security";
};

Unattended-Upgrade::DevRelease "false";
EOF
    elif is_debian; then
        # Debian-specific configuration
        cat > "$ua_conf" <<EOF
// Unattended-Upgrade configuration for Debian
// Generated by linux-base-setup on $(date)

Unattended-Upgrade::Origins-Pattern {
    "origin=Debian,codename=\${distro_codename},label=Debian";
    "origin=Debian,codename=\${distro_codename},label=Debian-Security";
    "origin=Debian,codename=\${distro_codename}-security,label=Debian-Security";
};
EOF
    fi
    
    # Common configuration for both distributions
    cat >> "$ua_conf" <<EOF

// Package blacklist (space-separated)
Unattended-Upgrade::Package-Blacklist {
};

// Auto-fix interrupted dpkg processes
Unattended-Upgrade::AutoFixInterruptedDpkg "true";

// Split the upgrade into smallest possible chunks
Unattended-Upgrade::MinimalSteps "true";

// Install updates on shutdown if not already running
Unattended-Upgrade::InstallOnShutdown "false";

// Send email notifications
Unattended-Upgrade::Mail "root";
Unattended-Upgrade::MailReport "only-on-error";

// Remove unused kernel packages
Unattended-Upgrade::Remove-Unused-Kernel-Packages "true";

// Remove unused dependencies
Unattended-Upgrade::Remove-Unused-Dependencies "true";

// Automatic reboot configuration
Unattended-Upgrade::Automatic-Reboot "$([ "$UNATTENDED_UPGRADES_AUTO_REBOOT" == "true" ] && echo "true" || echo "false")";
Unattended-Upgrade::Automatic-Reboot-WithUsers "false";
Unattended-Upgrade::Automatic-Reboot-Time "$UNATTENDED_UPGRADES_AUTO_REBOOT_TIME";

// Enable logging
Unattended-Upgrade::SyslogEnable "true";
Unattended-Upgrade::SyslogFacility "daemon";

// Verbose output
//Unattended-Upgrade::Verbose "true";
EOF
    
    # Configure auto-updates
    cat > "$auto_conf" <<EOF
// Enable automatic updates
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Download-Upgradeable-Packages "1";
APT::Periodic::AutocleanInterval "7";
APT::Periodic::Unattended-Upgrade "1";
EOF
    
    # Enable and start the service
    systemctl enable unattended-upgrades >> "$LOG_FILE" 2>&1
    systemctl start unattended-upgrades >> "$LOG_FILE" 2>&1
    
    log_success "Unattended upgrades configured for $(get_distribution | tr '[:lower:]' '[:upper:]')"
    
    # Display configuration
    unattended-upgrade --dry-run --debug 2>&1 | head -20 | tee -a "$LOG_FILE"
    
    return 0
}

configure_ntp() {
    log_section "Time Synchronization (NTP)"
    
    if [[ "$CONFIGURE_NTP" != "true" ]]; then
        log_info "NTP configuration disabled"
        return 0
    fi
    
    case "$NTP_SERVICE" in
        chrony)
            configure_chrony
            ;;
        systemd-timesyncd)
            configure_systemd_timesyncd
            ;;
        *)
            log_warning "Unknown NTP service: $NTP_SERVICE"
            return 1
            ;;
    esac
}

configure_chrony() {
    log_info "Configuring Chrony NTP service"
    
    # Install chrony
    install_package "chrony"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would configure Chrony"
        return 0
    fi
    
    local chrony_conf="/etc/chrony/chrony.conf"
    backup_file "$chrony_conf"
    
    # Configure chrony with better NTP servers
    cat > "$chrony_conf" <<EOF
# Chrony NTP Configuration
# Generated by linux-base-setup on $(date)

# NTP Servers (use servers close to your location)
pool 0.debian.pool.ntp.org iburst
pool 1.debian.pool.ntp.org iburst
pool 2.debian.pool.ntp.org iburst
pool 3.debian.pool.ntp.org iburst

# Record the rate at which the system clock gains/losses time
driftfile /var/lib/chrony/drift

# Allow the system clock to be stepped in the first three updates
makestep 1.0 3

# Enable kernel synchronization of the real-time clock (RTC)
rtcsync

# Specify directory for log files
logdir /var/log/chrony

# Select which information is logged
#log measurements statistics tracking
EOF
    
    # Enable and start chrony
    enable_service "chrony"
    restart_service "chrony"
    
    # Wait for sync
    sleep 3
    
    # Display status
    if command -v chronyc &>/dev/null; then
        log_success "Chrony NTP service configured"
        chronyc tracking | tee -a "$LOG_FILE"
    fi
    
    configure_timezone
    
    return 0
}

configure_systemd_timesyncd() {
    log_info "Configuring systemd-timesyncd NTP service"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would configure systemd-timesyncd"
        return 0
    fi
    
    local timesyncd_conf="/etc/systemd/timesyncd.conf"
    backup_file "$timesyncd_conf"
    
    cat > "$timesyncd_conf" <<EOF
# systemd-timesyncd configuration
# Generated by linux-base-setup on $(date)

[Time]
NTP=0.debian.pool.ntp.org 1.debian.pool.ntp.org 2.debian.pool.ntp.org 3.debian.pool.ntp.org
FallbackNTP=ntp.ubuntu.com
EOF
    
    # Enable and start timesyncd
    enable_service "systemd-timesyncd"
    restart_service "systemd-timesyncd"
    
    # Wait for sync
    sleep 3
    
    # Display status
    log_success "systemd-timesyncd configured"
    timedatectl status | tee -a "$LOG_FILE"
    
    configure_timezone
    
    return 0
}

configure_timezone() {
    log_info "Timezone Configuration"
    
    # Get timezone if not set
    if [[ -z "$TIMEZONE" ]]; then
        if [[ "$INTERACTIVE" == "true" ]]; then
            echo ""
            echo "Available timezones (showing US examples):"
            timedatectl list-timezones | grep America | head -10
            echo "..."
            echo ""
            TIMEZONE=$(prompt_input "Enter your timezone (e.g., America/New_York)" "UTC")
        else
            TIMEZONE="UTC"
        fi
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would set timezone to: $TIMEZONE"
        return 0
    fi
    
    # Validate timezone
    if timedatectl list-timezones | grep -q "^$TIMEZONE$"; then
        timedatectl set-timezone "$TIMEZONE"
        log_success "Timezone set to: $TIMEZONE"
        
        # Display current time
        log_info "Current system time: $(date)"
    else
        log_warning "Invalid timezone: $TIMEZONE, using UTC"
        timedatectl set-timezone "UTC"
    fi
    
    # Enable NTP
    timedatectl set-ntp true >> "$LOG_FILE" 2>&1
    
    return 0
}

configure_hostname() {
    log_section "Hostname Configuration"
    
    if [[ "$CONFIGURE_HOSTNAME" != "true" ]]; then
        log_info "Hostname configuration disabled"
        return 0
    fi
    
    # Generate hostname if not set
    if [[ -z "$HOSTNAME" ]]; then
        local suggested_hostname
        suggested_hostname=$(generate_hostname "$HOSTNAME_PREFIX")
        
        if [[ "$INTERACTIVE" == "true" ]]; then
            echo ""
            log_info "System Information:"
            get_system_info | tee -a "$LOG_FILE"
            echo ""
            log_info "Suggested hostname: $suggested_hostname"
            HOSTNAME=$(prompt_input "Enter desired hostname" "$suggested_hostname")
        else
            HOSTNAME="$suggested_hostname"
        fi
    fi
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "[DRY-RUN] Would set hostname to: $HOSTNAME"
        return 0
    fi
    
    log_info "Setting hostname to: $HOSTNAME"
    
    # Set hostname
    hostnamectl set-hostname "$HOSTNAME"
    
    # Update /etc/hosts
    local hosts_file="/etc/hosts"
    backup_file "$hosts_file"
    
    # Update 127.0.1.1 entry
    if grep -q "^127.0.1.1" "$hosts_file"; then
        sed -i "s/^127.0.1.1.*/127.0.1.1\t$HOSTNAME/" "$hosts_file"
    else
        echo "127.0.1.1	$HOSTNAME" >> "$hosts_file"
    fi
    
    # Ensure 127.0.0.1 includes hostname
    if ! grep -q "^127.0.0.1.*$HOSTNAME" "$hosts_file"; then
        sed -i "/^127.0.0.1/s/localhost/localhost $HOSTNAME/" "$hosts_file"
    fi
    
    log_success "Hostname configured: $HOSTNAME"
    
    # Verify
    log_info "Hostname verification:"
    echo "  hostnamectl: $(hostnamectl --static)"
    echo "  /etc/hostname: $(cat /etc/hostname)"
    
    return 0
}
